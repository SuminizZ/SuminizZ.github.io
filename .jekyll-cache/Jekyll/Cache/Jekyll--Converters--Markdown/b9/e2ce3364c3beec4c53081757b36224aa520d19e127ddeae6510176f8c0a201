I"è<h2 id="outlines"><strong>Outlines</strong></h2>
<ul>
  <li><a href="#reference"><strong>Reference</strong></a></li>
  <li><a href="#faster-r-cnn-vs-fast-r-cnn-vs-r-cnn"><strong>Faster R-CNN vs Fast R-CNN vs R-CNN</strong></a></li>
  <li><a href="#step-by-step-implementation-of-faster-r-cnn-with-pytorch"><strong>Step By Step Implementation of Faster R-CNN with PyTorch</strong></a>
    <ul>
      <li><a href="#0-sample-image-data-and-ground-truth-boxes"><strong>0. Sample Image Data and Ground-Truth Boxes</strong></a></li>
      <li><a href="#1-feature-extractor-vgg-16"><strong>1. Feature Extractor VGG-16</strong></a></li>
      <li><a href="#3-compute-intersection-over-union-iou-with-ground-truth-boxes"><strong>3. Compute Intersection Over Union (IoU) with Ground-Truth Boxes</strong></a></li>
      <li><a href="#4-get-lables-and-parameterized-coordinates-of-anchors"><strong>4. Get Lables and Parameterized Coordinates of Anchors</strong></a></li>
      <li><a href="#5-region-proposal-networks-rpn"><strong>5. Region Proposal Networks (RPN)</strong></a></li>
      <li><a href="#6-multi-tsk-loss"><strong>6. Multi-Task Loss</strong></a></li>
      <li><a href="#7-proposal-layer--nms--proposal-target-layers"><strong>7. Proposal Layer : NMS &amp; Proposal Target Layers</strong></a></li>
      <li><a href="#8-get-ground-truth-labels-and-paramterized-locations-of-selected-anchors"><strong>8. Get Ground-Truth Labels and Paramterized Locations of Selected Anchors</strong></a></li>
      <li><a href="#9-roi-pooling"><strong>9. RoI Pooling</strong></a></li>
      <li><a href="#10-fast-r-cnn"><strong>10. Fast R-CNN</strong></a></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="reference"><strong>Reference</strong></h2>

<p><br /></p>

<ul>
  <li><a href="https://arxiv.org/abs/1506.01497" target="_blank"><strong>Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks, Shaoqing Ren, 2015</strong></a></li>
  <li><a href="https://www.youtube.com/watch?v=4yOcsWg-7g8" target="_blank"><strong>How FasterRCNN works and step-by-step PyTorch implementation</strong></a></li>
</ul>

<p><br /></p>

<h2 id="faster-r-cnn-vs-fast-r-cnn-vs-r-cnn"><strong>Faster R-CNN</strong> vs <strong>Fast R-CNN</strong> vs <strong>R-CNN</strong></h2>

<p><br /></p>

<p>‚ÄÉ<img src="https://github.com/SuminizZ/Algorithm/assets/92680829/91341de2-0c34-40be-a6b3-d6a8b42f4ec7" width="700" /></p>

<p><br /></p>

<ul>
  <li>Faster R-CNN is an improvement of R-CNN and Fast R-CNN, integrating region proposal network (RPN) into the network architecture unlike R-CNN and fast R-CNN that adopt external RPN with selective search algorithm.</li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p><strong>R-CNN</strong></p>

    <ul>
      <li>
        <p>As an initial model of R-CNN series, R-CNN used a selective search algorithm to generate region proposals outside of the networks and then feed each of these proposals into a distinct CNN networks for feature extraction.</p>
      </li>
      <li>
        <p>These features are then subsequently passed to a set of FC layers to perform classification task and bounding box regression task, separately.</p>
      </li>
      <li>
        <p>Due to this multi-stage pipeline, R-CNN suffered from mutiple sets of computationally expensive operations included in the model architecture.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Fast R-CNN</strong></p>

    <ul>
      <li>
        <p>Also adopts external region proposals using selective search.</p>
      </li>
      <li>
        <p>Unlike R-CNN, Fast R-CNN shares one CNN across the entire image and then applies an RoI (Region of Interest) pooling layer to extract features all at once from a single output of the CNN.</p>
      </li>
      <li>
        <p>Integrating multiple CNNs into a single shared CNN significantly saves the amount of computations required.</p>
      </li>
      <li>
        <p>In addition, Fast R-CNN jointly optimizes the classification and regression tasks using multi-task loss, which is the sum of classification and regression loss.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Faster R-CNN</strong></p>

    <p>‚ÄÉ‚ÄÉ<img src="https://github.com/SuminizZ/Algorithm/assets/92680829/98fec387-b682-4759-b5c6-5661fbd50bd4" width="800" /></p>

    <ul>
      <li>
        <p>Faster R-CNN uses internal RPN, which shares CNN with object detection networks. This RPN directly generates region proposals from extracted feature maps and passes them into NMS and proposal target layers to get final region proposals.</p>
      </li>
      <li>
        <p>Multi-task loss is computed between the locations and labels of bounding boxes predicted from RPN and ground truth bounding boxes.</p>
      </li>
      <li>
        <p>NMS layer and proposal target layer use initially defined anchor boxes and computed ojectness scores from RPN.</p>
      </li>
      <li>
        <p>Then, applies RoI pooling to output feature map and extract final roi features based on the target proposals gained from proposal target layers.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="step-by-step-implementation-of-faster-r-cnn-with-pytorch"><strong>Step By Step Implementation of Faster R-CNN with PyTorch</strong></h2>

<p><br /></p>

<ul>
  <li><a href="https://github.com/SuminizZ/Implementation/tree/main/Faster_R-CNN" target="_blank"><strong>Full codes here</strong></a></li>
</ul>

<p><br /></p>

<h3 id="0-sample-image-data-and-ground-truth-boxes"><strong>0. Sample Image Data and Ground-Truth Boxes</strong></h3>

<p><br /></p>

<ul>
  <li>An image data with shape (3 x 800 x 800) that will used and its 4 ground truth bounding boxes that localizes the target objects.</li>
</ul>

<p>‚ÄÉ <img src="https://github.com/SuminizZ/Algorithm/assets/92680829/5998e933-6c04-4e6c-a8b8-ec28c1d02708" width="470" /></p>

<p><br /></p>

<h3 id="1-feature-extractor-vgg-16"><strong>1. Feature Extractor VGG-16</strong></h3>

<p><br /></p>

<ul>
  <li>
    <p>Implement pre-trained VGG-16 networks as a feature extractor to get output feature maps with desired sub sampling size, which in this case, 50.</p>
  </li>
  <li>
    <p>Firstly starts with 3 x 800 x 800 image and downsample it into 512 feature maps with 50 x 50 size. (final output shape : 512 x 50 x 50)</p>
  </li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FeatureExtractor</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">FeatureExtractor</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">torchvision</span><span class="p">.</span><span class="n">models</span><span class="p">.</span><span class="nf">vgg16</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">features</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">features</span><span class="p">)</span>

        <span class="n">dummy</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">800</span><span class="p">)).</span><span class="nf">float</span><span class="p">()</span>    <span class="c1"># test image array
</span>        <span class="n">req_features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="nf">feature</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dummy</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">800</span><span class="o">//</span><span class="mi">16</span><span class="p">:</span>     <span class="c1"># 800/16=50
</span>                <span class="k">break</span>
            <span class="n">req_features</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>
            <span class="n">out_channels</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">self</span><span class="p">.</span><span class="n">feature_extractor</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">req_features</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">feature_extractor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>
    <p>Input</p>

    <ul>
      <li>x : 3 x 800 x 800 images</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="2-anchor-generation-layers"><strong>2. Anchor Generation Layers</strong></h3>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_anchors</span><span class="p">(</span><span class="n">feature_size</span><span class="p">):</span>
    <span class="n">ctr</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">empty</span><span class="p">((</span><span class="n">feature_size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">ctr_x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="p">(</span><span class="n">feature_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">ctr_y</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="p">(</span><span class="n">feature_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

    <span class="n">anc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ctr_x</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">ctr_y</span><span class="p">:</span>
            <span class="n">ctr</span><span class="p">[</span><span class="n">anc</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">8</span>
            <span class="n">ctr</span><span class="p">[</span><span class="n">anc</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">8</span>
            <span class="n">anc</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">ratios</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">]</span>
    <span class="n">combs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ratios</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scales</span><span class="p">]</span>
    <span class="n">base_size</span> <span class="o">=</span> <span class="mi">8</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">anchor_boxes</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">empty</span><span class="p">((</span><span class="n">feature_size</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">ctr</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">combs</span><span class="p">:</span>
            <span class="n">ratio</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">z</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">scale</span><span class="o">*</span><span class="n">base_size</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">scale</span><span class="o">*</span><span class="n">base_size</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">ratio</span><span class="p">))</span>
            <span class="n">anchor_boxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">([</span><span class="n">x</span><span class="o">-</span><span class="n">w</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="n">h</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">w</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">h</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">anchor_boxes</span>
</code></pre></div></div>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">select_valid_anchors</span><span class="p">(</span><span class="n">anchor_boxes</span><span class="p">):</span>
    <span class="n">valid_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">((</span><span class="n">anchor_boxes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>
                          <span class="p">(</span><span class="n">anchor_boxes</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>
                          <span class="p">(</span><span class="n">anchor_boxes</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">800</span><span class="p">)</span> <span class="o">&amp;</span>
                          <span class="p">(</span><span class="n">anchor_boxes</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">800</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">valid_anchors</span> <span class="o">=</span> <span class="n">anchor_boxes</span><span class="p">[</span><span class="n">valid_idxs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">valid_idxs</span><span class="p">,</span> <span class="n">valid_anchors</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>
    <p>Argument</p>

    <ul>
      <li>feature size : 50</li>
    </ul>
  </li>
  <li>
    <p>Generates candidate anchor bounding boxes with various sizes and ratios.</p>

    <ul>
      <li>
        <p>sub-sampling rate = 1/16</p>
      </li>
      <li>
        <p>image size : 800 x 800</p>
      </li>
      <li>
        <p>sub-sampled feature map size : 800 x 1/16 = 50</p>
      </li>
      <li>
        <p>50 x 50 = 2500 anchors and each anchor generate 9 anchor boxes with varying scales (3) and ratios (3)</p>
      </li>
      <li>
        <p>total anchor boxes = 50 x 50 x 9 = 22500</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Select only valid anchors whose 4 coordinates are within 800 x 800 initial image size.</p>
  </li>
</ul>

<p><br /></p>

<p>‚ÄÉ‚ÄÉ<strong>Display some of the generated anchor boxes (<span style="color:red;">red</span>) and the ground truth boxes (<span style="color:green;">green</span>)</strong></p>

<p>‚ÄÉ‚ÄÉ‚ÄÉ<img src="https://github.com/SuminizZ/Algorithm/assets/92680829/4e04e24e-7b6f-4a8b-9458-b52274f4fb5b" width="500" /></p>

<p><br /></p>

<h3 id="3-compute-intersection-over-union-iou-with-ground-truth-boxes"><strong>3. Compute Intersection Over Union (IoU) with Ground-Truth Boxes</strong></h3>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_IoUs</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">valid_anchors</span><span class="p">):</span>
    <span class="n">ious</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">((</span><span class="nf">len</span><span class="p">(</span><span class="n">valid_anchors</span><span class="p">),</span> <span class="n">bbox</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">*-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">box</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">bbox</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">box</span>
        <span class="n">ax1</span><span class="p">,</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ay2</span> <span class="o">=</span> <span class="n">valid_anchors</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">valid_anchors</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">valid_anchors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">valid_anchors</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">max_x1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
        <span class="n">max_y1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">ay1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>
        <span class="n">min_x2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
        <span class="n">min_y2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">ay2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">((</span><span class="n">max_x1</span> <span class="o">&lt;</span> <span class="n">min_x2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">max_y1</span> <span class="o">&lt;</span> <span class="n">min_y2</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tot_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax2</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">-</span> <span class="n">ax1</span><span class="p">[</span><span class="n">idxs</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">ay2</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">-</span> <span class="n">ay1</span><span class="p">[</span><span class="n">idxs</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y2</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span>
        <span class="n">overlapped_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_x2</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_x1</span><span class="p">[</span><span class="n">idxs</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">min_y2</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_y1</span><span class="p">[</span><span class="n">idxs</span><span class="p">])</span>
        <span class="n">ious</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="n">overlapped_area</span> <span class="o">/</span> <span class="p">(</span><span class="n">tot_area</span> <span class="o">-</span> <span class="n">overlapped_area</span><span class="p">)</span>

    <span class="c1"># print(ious[8930:8940, :])
</span>    <span class="k">return</span> <span class="n">ious</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>
    <p>Function that computes IoU with ground truth boxes.</p>
  </li>
  <li>
    <p>IoU = overlapped area / total area</p>

    <ul>
      <li>total area = anchor box area + ground truth box area - overlapped area</li>
    </ul>
  </li>
  <li>
    <p>Used to assign labels for each anchor box and later be used in NMS and proposal target layers.</p>
  </li>
</ul>

<p><br /></p>

<h3 id="4-get-lables-and-parameterized-coordinates-of-anchors"><strong>4. Get Lables and Parameterized Coordinates of Anchors</strong></h3>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_anchor_labels</span><span class="p">(</span><span class="n">ious</span><span class="p">,</span> <span class="n">valid_anchors</span><span class="p">):</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">ious</span><span class="p">))</span><span class="o">*-</span><span class="mi">1</span>

    <span class="n">max_iou_idxs</span> <span class="o">=</span> <span class="n">ious</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>    <span class="c1"># highest IoU with each ground truth box 
</span>    <span class="n">max_iou</span> <span class="o">=</span> <span class="n">ious</span><span class="p">[</span><span class="n">max_iou_idxs</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">ious</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">-</span> <span class="mf">0.01</span>  
    <span class="nf">print</span><span class="p">(</span><span class="n">max_iou</span><span class="p">)</span>
    <span class="n">labels</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">ious</span> <span class="o">&gt;=</span> <span class="n">max_iou</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">ious</span> <span class="o">&gt;=</span> <span class="n">max_iou</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">max_iou_gtb_idxs</span> <span class="o">=</span> <span class="n">ious</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># index of ground truth box of highest IoU with each anchor box
</span>    <span class="n">max_iou_gtb_vals</span> <span class="o">=</span> <span class="n">ious</span><span class="p">[</span><span class="n">torch</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">max_iou_gtb_idxs</span><span class="p">)),</span> <span class="n">max_iou_gtb_idxs</span><span class="p">]</span>

    <span class="n">pos_label_threshold</span> <span class="o">=</span> <span class="mf">0.7</span>
    <span class="n">neg_label_threshold</span> <span class="o">=</span> <span class="mf">0.3</span>

    <span class="n">labels</span><span class="p">[</span><span class="n">max_iou_gtb_vals</span> <span class="o">&gt;=</span>  <span class="n">pos_label_threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>    
    <span class="n">labels</span><span class="p">[</span><span class="n">max_iou_gtb_vals</span> <span class="o">&lt;</span>  <span class="n">neg_label_threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">max_iou_bbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="n">max_iou_gtb_idxs</span><span class="p">]</span>

    <span class="n">n_sample</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">pos_ratio</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">n_pos</span> <span class="o">=</span> <span class="n">pos_ratio</span> <span class="o">*</span> <span class="n">n_sample</span>

    <span class="n">pos_index</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">pos_index</span><span class="p">))</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">pos_index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_pos</span><span class="p">:</span>
        <span class="n">disable_index</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">pos_index</span><span class="p">,</span>
                                        <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">pos_index</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_pos</span><span class="p">),</span>
                                        <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">disable_index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>
    <p>Get <strong>labels</strong> for every valid anchor boxes.</p>

    <ul>
      <li>
        <p>Set label = 1 (object) if</p>

        <ol>
          <li>
            <p>Anchor boxes that have highest IoU with each ground truth box.</p>
          </li>
          <li>
            <p>Each anchor‚Äôs highest IoU &gt;= 0.7</p>
          </li>
        </ol>
      </li>
      <li>
        <p>label = 0 (background) if IoU less than 0.3</p>
      </li>
      <li>
        <p>otherwise, all are set to be -1, which will be ignored in further steps.</p>
      </li>
      <li>
        <p>Fix the upper limit of the number of positive labels as 128. If the number of positively labeled boxes is bigger than the limit, randomly de-select them untill it reaches to the limit.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># parameterizes the 4 coordinates of anchor boxes with each one's closest ground-truth boxe
</span>
<span class="k">def</span> <span class="nf">get_anchor_regs</span><span class="p">(</span><span class="n">ious</span><span class="p">,</span> <span class="n">valid_anchors</span><span class="p">,</span> <span class="n">bbox</span><span class="p">):</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>

    <span class="n">max_iou_gt_idxs</span> <span class="o">=</span> <span class="n">ious</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gt_locs</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="n">max_iou_gt_idxs</span><span class="p">]</span>

    <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_locs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">gt_locs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">gt_locs</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">gt_locs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">ctr_x</span><span class="p">,</span> <span class="n">ctr_y</span> <span class="o">=</span> <span class="n">gt_locs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">gt_locs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="mf">0.5</span>

    <span class="n">wa</span><span class="p">,</span> <span class="n">ha</span> <span class="o">=</span> <span class="p">(</span><span class="n">valid_anchors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">valid_anchors</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">valid_anchors</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">valid_anchors</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">ctr_xa</span><span class="p">,</span> <span class="n">ctr_ya</span> <span class="o">=</span> <span class="n">valid_anchors</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">wa</span><span class="o">*</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">valid_anchors</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ha</span><span class="o">*</span><span class="mf">0.5</span>

    <span class="n">eps</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">finfo</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">dtype</span><span class="p">).</span><span class="n">eps</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">wa</span><span class="p">,</span> <span class="n">ha</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">wa</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>

    <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctr_x</span> <span class="o">-</span> <span class="n">ctr_xa</span><span class="p">)</span><span class="o">/</span><span class="n">wa</span><span class="p">,</span> <span class="p">(</span><span class="n">ctr_y</span> <span class="o">-</span> <span class="n">ctr_ya</span><span class="p">)</span><span class="o">/</span><span class="n">ha</span>
    <span class="n">dw</span><span class="p">,</span> <span class="n">dh</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">wa</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="n">ha</span><span class="p">)</span>

    <span class="n">gt_regs</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">dx</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">dy</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">dw</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">dh</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gt_regs</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>
    <p>Get <strong>parameterized locations</strong> of anchor boxes.</p>

    <ul>
      <li>
        <p>Parameterizes the 4 coordinates of anchor boxes with each one‚Äôs closest ground-truth boxes.</p>

        <p><img src="https://github.com/SuminizZ/Algorithm/assets/92680829/441f95de-d867-400e-a40c-084062597999" width="400" /></p>
      </li>
      <li>
        <p>$\large x,\, y,\, w,\, h$ refer to the location of center (x, y) and width, height of the predicted boxes.</p>
      </li>
      <li>
        <p>$\large x^{*},\, y^{*},\, w^{*},\, h^{*}$ are for ground-truth boxes.</p>
      </li>
      <li>
        <p>$\large x_{a},\, y_{a},\, w_{a},\, h_{a}$ are for anchor boxes created from anchor generation layers.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="5-region-proposal-networks-rpn"><strong>5. Region Proposal Networks (RPN)</strong></h3>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">RPN</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n_anchor</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">RPN</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>

        <span class="c1"># classifier (whether an anchor contains an object or not)
</span>        <span class="n">self</span><span class="p">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                        <span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">n_anchor</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="c1"># bounding box regressor (parameterized coordinates)
</span>        <span class="n">self</span><span class="p">.</span><span class="n">regressor</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                       <span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">n_anchor</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="nf">modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="p">.</span><span class="n">Conv2d</span><span class="p">):</span>
                <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="nf">normal_</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">weight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
                <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="nf">constant_</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">bias</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">class_scores</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">classifier</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">anchor_regs</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">regressor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">class_scores</span><span class="p">,</span> <span class="n">anchor_regs</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>
    <p>Generates region proposals along with the objectness scores</p>
  </li>
  <li>
    <p><strong>Region Proposal</strong></p>

    <ul>
      <li>
        <p>Regressor using Conv2d layer (in_channels = 512, out_channels = 512)</p>
      </li>
      <li>
        <p>output size n_batch x (22500 * 4) where 4 represents the 4 parameterized coordinates of each anchor box.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Object Classifier</strong></p>

    <ul>
      <li>
        <p>Classifier using Conv2d layer</p>
      </li>
      <li>
        <p>output size n_batch x (22500 * 2) where 2 represents the objectness scores, each one for positive and negative.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="6-multi-task-loss"><strong>6. Multi-Task Loss</strong></h3>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">multi_task_loss</span><span class="p">(</span><span class="n">pred_clss_scores</span><span class="p">,</span> <span class="n">gt_labels</span><span class="p">,</span> <span class="n">pred_regs</span><span class="p">,</span> <span class="n">gt_regs</span><span class="p">,</span> <span class="n">lamda</span><span class="p">,</span> <span class="n">use_pos_mask</span><span class="p">):</span>
    <span class="c1"># classification loss
</span>    <span class="n">L_clss</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">cross_entropy</span><span class="p">(</span><span class="n">pred_clss_scores</span><span class="p">,</span> <span class="n">gt_labels</span><span class="p">.</span><span class="nf">long</span><span class="p">(),</span> <span class="n">ignore_index</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># normalized with batch size
</span>
    <span class="n">pos_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">gt_labels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># regression loss is activated only for positive anchors (ground-truth)
</span>    <span class="k">if</span> <span class="n">use_pos_mask</span><span class="p">:</span>
        <span class="n">pos_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">pred_regs</span><span class="p">)</span>
        <span class="n">pos_mask</span><span class="p">[</span><span class="n">pos_idxs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">pred_regs</span> <span class="o">*=</span> <span class="n">pos_mask</span>
        <span class="n">gt_regs</span> <span class="o">*=</span> <span class="n">pos_mask</span>

    <span class="c1"># smooth L1
</span>    <span class="n">dreg</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">pred_regs</span> <span class="o">-</span> <span class="n">gt_regs</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">L_reg</span> <span class="o">=</span> <span class="p">((</span><span class="n">dreg</span> <span class="o">&lt;</span> <span class="n">beta</span><span class="p">).</span><span class="nf">float</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dreg</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">dreg</span> <span class="o">&gt;=</span> <span class="n">beta</span><span class="p">).</span><span class="nf">float</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">dreg</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="n">N_reg</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">pos_idxs</span><span class="p">)</span>

    <span class="n">mtl</span> <span class="o">=</span> <span class="n">L_clss</span> <span class="o">+</span> <span class="n">lamda</span><span class="o">*</span><span class="p">(</span><span class="n">L_reg</span><span class="p">.</span><span class="nf">sum</span><span class="p">()</span><span class="o">/</span><span class="n">N_reg</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Classification Error : </span><span class="si">{</span><span class="n">L_clss</span><span class="si">}</span><span class="s">  Regression Error : </span><span class="si">{</span><span class="n">L_reg</span><span class="p">.</span><span class="nf">sum</span><span class="p">()</span><span class="o">/</span><span class="n">N_reg</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mtl</span>
</code></pre></div></div>

<p><br /></p>

<p>‚ÄÉ<img src="https://github.com/SuminizZ/Algorithm/assets/92680829/d90e9c83-ac74-4d65-b14a-a1929aab27d4" width="380" /></p>

<p><br /></p>

<ul>
  <li>
    <p><strong>L_clss</strong> : classification loss</p>

    <ul>
      <li>cross entropy between predicted clss scores and ground truth labels</li>
    </ul>
  </li>
  <li>
    <p><strong>L_reg</strong> : regression loss of anchor coordinates</p>

    <ul>
      <li>
        <p>L1 smooth loss : activated only for positively labeled anchors (ground-truth labels)</p>
      </li>
      <li>
        <p>$\large p_{i}$ denotes predicted probability of anchor $\large i$ being labeled as positive (object)</p>
      </li>
      <li>
        <p>$\large t_{i}$ is a vector containing the 4 parameterized coordinates of the predicted bounding box $\large i$</p>
      </li>
      <li>
        <p>Asterik mark (*) represents ground-truth.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>$\large \lambda$</strong> is a weight hyperparameter for balancing the scale between two distinct losses. (L_clss is normalized with batch size and L_reg is normalized with the number of anchors)</p>

    <ul>
      <li>By default, set as 10.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="7-proposal-layer--nms--proposal-target-layers"><strong>7. Proposal Layer : NMS &amp; Proposal Target Layers</strong></h3>

<p><br /></p>

<ul>
  <li>
    <p>So far, we got region proposals from RPN in previous step and computed the multi-task loss for those proposals.</p>
  </li>
  <li>
    <p>Now, we need to select final target region proposals (Region of Interest, RoI) that are to be passed to subsequent RoI pooling layer.</p>
  </li>
  <li>
    <p>To do this, two additional layers 1. NMS and 2. Proposal Target Layers are added.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="non-maximum-suppression-nms"><strong>Non Maximum Suppression (NMS)</strong></h4>

<p><br /></p>

<ul>
  <li>
    <p>This layer aims to remove repetitive anchor boxes that capures identical object.</p>
  </li>
  <li>
    <p>Firstly, get indices descendingly sorted based on the objectness scores computed from RPN layer with pre-defined length (n_pre_nms) and slice the predicted anchor locations and labels with the sorted indices.</p>
  </li>
  <li>
    <p>Using while loop, pick the first anchor (the one with largets objectness score) and remove the anchors that have higher IoUs than nms threshold with that selected anchor, assuming that those anchors are capturing same object.</p>
  </li>
  <li>
    <p>Repeat the loop untill the list of ordered indices becomes empty.</p>
  </li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">non_maximum_supp</span><span class="p">(</span><span class="n">pred_regs</span><span class="p">,</span> <span class="n">objectness_scores</span><span class="p">,</span> <span class="n">anchor_boxes</span><span class="p">,</span> <span class="n">img_size</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">n_pre_nms</span><span class="p">,</span> <span class="n">n_post_nms</span><span class="p">,</span> <span class="n">nms_thresh</span><span class="p">):</span>
    <span class="n">ha</span> <span class="o">=</span> <span class="n">anchor_boxes</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">anchor_boxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">wa</span> <span class="o">=</span> <span class="n">anchor_boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">anchor_boxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">ctr_ya</span> <span class="o">=</span> <span class="n">anchor_boxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ha</span>
    <span class="n">ctr_xa</span> <span class="o">=</span> <span class="n">anchor_boxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">wa</span>

    <span class="n">dx</span> <span class="o">=</span> <span class="n">pred_regs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">pred_regs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">dw</span> <span class="o">=</span> <span class="n">pred_regs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="n">pred_regs</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>

    <span class="n">ctr_x</span><span class="p">,</span> <span class="n">ctr_y</span> <span class="o">=</span> <span class="n">dx</span><span class="o">*</span><span class="n">wa</span> <span class="o">+</span> <span class="n">ctr_xa</span><span class="p">,</span> <span class="n">dy</span><span class="o">*</span><span class="n">ha</span> <span class="o">+</span> <span class="n">ctr_ya</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">dw</span><span class="p">)</span><span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span><span class="o">*</span><span class="n">ha</span>

    <span class="n">roi</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">pred_regs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pred_regs</span><span class="p">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">roi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctr_x</span> <span class="o">-</span> <span class="n">w</span><span class="o">*</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ctr_y</span> <span class="o">-</span> <span class="n">h</span><span class="o">*</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ctr_x</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ctr_y</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="mf">0.5</span>

    <span class="c1"># clipping the min &amp; max of roi to img size
</span>    <span class="n">roi</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">clip</span><span class="p">(</span><span class="n">roi</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">roi</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">clip</span><span class="p">(</span><span class="n">roi</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">hs</span> <span class="o">=</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">((</span><span class="n">hs</span> <span class="o">&gt;=</span> <span class="n">min_size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ws</span> <span class="o">&gt;=</span> <span class="n">min_size</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">roi</span><span class="p">,</span> <span class="n">scores</span> <span class="o">=</span> <span class="n">roi</span><span class="p">[</span><span class="n">keep</span><span class="p">],</span> <span class="n">objectness_scores</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

    <span class="n">order_idxs</span> <span class="o">=</span> <span class="n">scores</span><span class="p">.</span><span class="nf">ravel</span><span class="p">().</span><span class="nf">argsort</span><span class="p">(</span><span class="n">descending</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:</span><span class="n">n_pre_nms</span><span class="p">]</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">order_idxs</span><span class="p">)</span>
    <span class="n">roi</span><span class="p">,</span> <span class="n">scores</span> <span class="o">=</span> <span class="n">roi</span><span class="p">[</span><span class="n">order_idxs</span><span class="p">],</span> <span class="n">scores</span><span class="p">[</span><span class="n">order_idxs</span><span class="p">]</span>

    <span class="n">keep</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">areas</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>    <span class="c1"># area of each anchor
</span>
    <span class="n">order_idxs</span> <span class="o">=</span> <span class="n">order_idxs</span><span class="p">.</span><span class="nf">argsort</span><span class="p">(</span><span class="n">descending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="nf">while </span><span class="p">(</span><span class="n">order_idxs</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">order_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">keep</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">max_x1</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="n">order_idxs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">max_y1</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">y1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">order_idxs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">min_x2</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">order_idxs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">min_y2</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">y2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y2</span><span class="p">[</span><span class="n">order_idxs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>

        <span class="n">inter</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="mf">0.</span><span class="p">),</span> <span class="n">min_x2</span> <span class="o">-</span> <span class="n">max_x1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="mf">0.</span><span class="p">),</span> <span class="n">min_x2</span> <span class="o">-</span> <span class="n">max_x1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">ious</span> <span class="o">=</span> <span class="n">inter</span> <span class="o">/</span> <span class="p">(</span><span class="n">areas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">areas</span><span class="p">[</span><span class="n">order_idxs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">-</span> <span class="n">inter</span><span class="p">)</span>
        <span class="n">keep_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">ious</span> <span class="o">&lt;=</span> <span class="n">nms_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">order_idxs</span> <span class="o">=</span> <span class="n">order_idxs</span><span class="p">[</span><span class="n">keep_idxs</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">keep</span> <span class="o">=</span> <span class="n">keep</span><span class="p">[:</span><span class="n">n_post_nms</span><span class="p">]</span>
    <span class="n">roi</span> <span class="o">=</span> <span class="n">roi</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">roi</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="proposal-target-layer"><strong>Proposal Target Layer</strong></h4>

<p><br /></p>

<ul>
  <li>
    <p>Proposal target layer selects samples from region proposals that are mostly useful for traininig the fast R-CNN.</p>
  </li>
  <li>
    <p>Calcuates the IoU between predicted anchors filtered from NMS layer and ground-truth boxes and only choose the anchors with IoU higher than certain threshold (which is here, 0.7)</p>
  </li>
  <li>
    <p>The number of positive sample regions per image is fixed (here, 64) and so is for negative sample regions (64).</p>
  </li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">proposal_target_layer</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">n_sample</span><span class="p">,</span> <span class="n">pos_ratio</span><span class="p">,</span> <span class="n">pos_iou_thresh</span><span class="p">):</span>
    <span class="n">ious</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones_like</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span><span class="o">*-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">box</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">bbox</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">box</span>
        <span class="n">ax1</span><span class="p">,</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ay2</span> <span class="o">=</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">roi</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">max_x1</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
        <span class="n">max_y1</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">ay1</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">y1</span><span class="p">))</span>
        <span class="n">min_x2</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
        <span class="n">min_y2</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">ay2</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">((</span><span class="n">max_x1</span> <span class="o">&lt;</span> <span class="n">min_x2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">max_y1</span> <span class="o">&lt;</span> <span class="n">min_y2</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tot_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax2</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">-</span> <span class="n">ax1</span><span class="p">[</span><span class="n">idxs</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">ay2</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">-</span> <span class="n">ay1</span><span class="p">[</span><span class="n">idxs</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y2</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span>
        <span class="n">inter_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_x2</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_x1</span><span class="p">[</span><span class="n">idxs</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">min_y2</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_y1</span><span class="p">[</span><span class="n">idxs</span><span class="p">])</span>
        <span class="n">ious</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="n">inter_area</span> <span class="o">/</span> <span class="p">(</span><span class="n">tot_area</span> <span class="o">-</span> <span class="n">inter_area</span><span class="p">)</span>

    <span class="n">max_iou_gt_idxs</span> <span class="o">=</span> <span class="n">ious</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">max_iou_gt_vals</span> <span class="o">=</span> <span class="n">ious</span><span class="p">[</span><span class="n">torch</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">roi</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">max_iou_gt_idxs</span><span class="p">]</span>

    <span class="c1"># select positive samples
</span>    <span class="n">pos_roi_per_image</span> <span class="o">=</span> <span class="n">n_sample</span> <span class="o">*</span> <span class="n">pos_ratio</span>
    <span class="n">pos_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">max_iou_gt_vals</span> <span class="o">&gt;=</span> <span class="n">pos_iou_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pos_roi_per_this_image</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">min</span><span class="p">(</span><span class="n">pos_roi_per_image</span><span class="p">,</span> <span class="n">pos_idxs</span><span class="p">.</span><span class="n">size</span><span class="p">))</span>

    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">pos_idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">pos_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">pos_idxs</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">pos_roi_per_this_image</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="c1"># select negtative (backgroud) samples
</span>    <span class="n">neg_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">((</span><span class="n">max_iou_gt_vals</span> <span class="o">&lt;</span> <span class="n">pos_iou_thresh</span><span class="p">)</span> <span class="o">&amp;</span>
                        <span class="p">(</span><span class="n">max_iou_gt_vals</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">neg_roi_per_this_image</span> <span class="o">=</span> <span class="n">n_sample</span> <span class="o">-</span> <span class="n">pos_roi_per_this_image</span>
    <span class="n">neg_roi_per_this_image</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">min</span><span class="p">(</span><span class="n">neg_roi_per_this_image</span><span class="p">,</span> <span class="n">neg_idxs</span><span class="p">.</span><span class="n">size</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">neg_idxs</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">neg_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">neg_idxs</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">neg_roi_per_this_image</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ious</span><span class="p">,</span> <span class="n">pos_idxs</span><span class="p">,</span> <span class="n">neg_idxs</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>Visualize selected positive and negative achor boxes from proposal target layers onto the image.</li>
</ul>

<p>‚ÄÉ‚ÄÉ <strong>Positive Anchors</strong></p>

<p><img src="https://github.com/SuminizZ/Algorithm/assets/92680829/44db442d-40cc-4486-811b-8cac85fe45cd" width="500" /></p>

<p>‚ÄÉ‚ÄÉ <strong>Negative Anchors</strong></p>

<p><img src="https://github.com/SuminizZ/Algorithm/assets/92680829/ca594df1-f9c7-489b-8a82-a57196f2ae46" width="500" /></p>

<p><br /></p>

<h3 id="8-get-ground-truth-labels-and-paramterized-locations-of-selected-anchors"><strong>8. Get Ground-Truth Labels and Paramterized Locations of Selected Anchors</strong></h3>

<p><br /></p>

<ul>
  <li>For supervised training in fast R-CNN, we need to prepare ground truth labels and locations of the proposed anchor boxes (RoIs).</li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ground_truth_rois</span><span class="p">(</span><span class="n">ious</span><span class="p">,</span> <span class="n">rois</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">pos_idxs</span><span class="p">,</span> <span class="n">neg_idxs</span><span class="p">):</span>
    <span class="n">keep_idxs</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">pos_idxs</span><span class="p">,</span> <span class="n">neg_idxs</span><span class="p">)).</span><span class="nf">long</span><span class="p">()</span>

    <span class="n">gt_roi_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">keep_idxs</span><span class="p">))</span>
    <span class="n">gt_roi_labels</span><span class="p">[:</span><span class="nf">len</span><span class="p">(</span><span class="n">pos_idxs</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">sroi</span> <span class="o">=</span> <span class="n">rois</span><span class="p">[</span><span class="n">keep_idxs</span><span class="p">]</span>    <span class="c1"># sample roi extracted from proposal target layers
</span>    <span class="n">bbox_sroi</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="n">ious</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="n">keep_idxs</span><span class="p">]]</span>

    <span class="n">eps</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">finfo</span><span class="p">(</span><span class="n">sroi</span><span class="p">.</span><span class="n">dtype</span><span class="p">).</span><span class="n">eps</span>

    <span class="c1"># sampled roi (pred)
</span>    <span class="n">w</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">sroi</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">sroi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">sroi</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">sroi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span>
    <span class="n">ctr_x</span> <span class="o">=</span> <span class="n">sroi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span>
    <span class="n">ctr_y</span> <span class="o">=</span> <span class="n">sroi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span>

    <span class="n">gt_w</span> <span class="o">=</span> <span class="n">bbox_sroi</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bbox_sroi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">gt_h</span> <span class="o">=</span> <span class="n">bbox_sroi</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">bbox_sroi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">gt_ctr_x</span> <span class="o">=</span> <span class="n">bbox_sroi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gt_w</span>
    <span class="n">gt_ctr_y</span> <span class="o">=</span> <span class="n">bbox_sroi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gt_h</span>

    <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_ctr_x</span> <span class="o">-</span> <span class="n">ctr_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">w</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_ctr_y</span> <span class="o">-</span> <span class="n">ctr_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">h</span>
    <span class="n">dw</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">gt_w</span> <span class="o">/</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">gt_h</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span>

    <span class="n">gt_roi_regs</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">dx</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">dy</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">dw</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">dh</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gt_roi_labels</span><span class="p">,</span> <span class="n">gt_roi_regs</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="9-roi-pooling"><strong>9. RoI Pooling</strong></h3>

<p><br /></p>

<ul>
  <li>
    <p>Through this layer, actual features of the image (from feature extractor layer) now will be pooled based on the previously gained labels and coordinates of target RoIs.</p>
  </li>
  <li>
    <p>This layer will adopt <strong>global average pooling layer</strong> to get final feature extractions, which are the inputs of the fast R-CNN.</p>
  </li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># get img feature maps at predicted coordinates
</span>
<span class="k">def</span> <span class="nf">roi_pooling</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">pos_idxs</span><span class="p">,</span> <span class="n">neg_idxs</span><span class="p">,</span> <span class="n">output_map</span><span class="p">):</span>
    <span class="n">keep_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">pos_idxs</span><span class="p">,</span> <span class="n">neg_idxs</span><span class="p">)</span>
    <span class="n">gt_roi_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">keep_idxs</span><span class="p">))</span>
    <span class="n">gt_roi_labels</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">pos_idxs</span><span class="p">):]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sample_rois</span> <span class="o">=</span> <span class="n">rois</span><span class="p">[</span><span class="n">keep_idxs</span><span class="p">]</span>

    <span class="n">admaxpool</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">AdaptiveMaxPool2d</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rois</span> <span class="o">=</span> <span class="n">sample_rois</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">16</span><span class="p">)</span>    <span class="c1"># sub-sampling ratio
</span>    <span class="n">rois</span> <span class="o">=</span> <span class="n">rois</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
    <span class="n">rois</span> <span class="o">=</span> <span class="n">rois</span><span class="p">.</span><span class="nf">long</span><span class="p">()</span>    <span class="c1"># turn each loc into integers
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">rois</span><span class="p">)):</span>
        <span class="n">roi</span> <span class="o">=</span> <span class="n">rois</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">output_map</span><span class="p">.</span><span class="nf">narrow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[...,</span> <span class="n">roi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:(</span><span class="n">roi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">roi</span><span class="p">[</span><span class="mi">1</span><span class="p">]:(</span><span class="n">roi</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>   <span class="c1"># i : channel indexing
</span>        <span class="n">tmp</span> <span class="o">=</span> <span class="nf">admaxpool</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="n">output</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>     <span class="c1"># 128 x 512 x 7 x 7
</span>    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"roi pooling output size : </span><span class="si">{</span><span class="n">output</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">output</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># 128 x (512*7*7 = 25088)
</span>
    <span class="k">return</span> <span class="n">k</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>
    <p>For all those positive (64) and negative roi (64) samples, we need to multiply the sub-sampling ratio (1/16) to rescale the locations of roi (800 x 800) into feature map size (50 x 50).</p>
  </li>
  <li>
    <p>Then performs roi pooling across all samples and apply adaptive GAP to make final output feature map size 7 x 7.</p>
  </li>
  <li>
    <p>After completing the for loop (x 128), concat the resultant (512 x 7 x 7) feature maps along the dimension 0. (final output shape : 128 x 512 x 7 x 7)</p>
  </li>
</ul>

<p><br /></p>

<h3 id="10-fast-r-cnn"><strong>10. Fast R-CNN</strong></h3>

<p><br /></p>

<ul>
  <li>The last fully connected layers of this model that performs classification and regression tasks to get final labels and locations of pooled RoIs.</li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FastRCNN</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">FastRCNN</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">num_rois</span><span class="p">,</span> <span class="n">in_channels</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">),</span>
                                  <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">roi_regs</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">out_channels</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>    <span class="c1"># 8 : 1 class, 1 background, 4 coordiinates
</span>        <span class="n">self</span><span class="p">.</span><span class="n">roi_clss</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">out_channels</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="nf">modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">):</span>
                <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="nf">normal_</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">weight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
                <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="nf">constant_</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">bias</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">base</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">pred_roi_regs</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">roi_regs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">pred_roi_clss</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">roi_clss</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred_roi_regs</span><span class="p">,</span> <span class="n">pred_roi_clss</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>
    <p>Input : flattened features extracted from RoI pooling layer (128 x (512<em>7</em>7 = 25088))</p>
  </li>
  <li>
    <p>Ouput :</p>

    <ul>
      <li>
        <p>Regression : coordinates of background (if labeled as 0) and object (if label = 1)</p>
      </li>
      <li>
        <p>Classification : assign label 0 or 1 to tell if the given anchor captures an object or not.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Finally, calculate multi task loss between predicted anchors and ground truth boxes.</p>
  </li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pred_roi_regs</span> <span class="o">=</span> <span class="n">pred_roi_regs</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">n_sample</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">pred_roi_regs</span> <span class="o">=</span> <span class="n">pred_roi_regs</span><span class="p">[</span><span class="n">torch</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_sample</span><span class="p">).</span><span class="nf">long</span><span class="p">(),</span> <span class="n">gt_roi_labels</span><span class="p">.</span><span class="nf">long</span><span class="p">()]</span>
<span class="n">mtl</span> <span class="o">=</span> <span class="nf">multi_task_loss</span><span class="p">(</span><span class="n">pred_roi_clss</span><span class="p">,</span> <span class="n">gt_roi_labels</span><span class="p">,</span> <span class="n">pred_roi_regs</span><span class="p">,</span> <span class="n">gt_roi_regs</span><span class="p">,</span> <span class="n">lamda</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Multi Task Loss : </span><span class="si">{</span><span class="n">mtl</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Classification Error : 0.6667768955230713  Regression Error : 2.890517234802246
Multi Task Loss : 29.571949005126953
</code></pre></div></div>
<p><br /></p>

<hr />

<p><br /></p>

<ul>
  <li>
    <p>So far, we‚Äôve implemented Faster R-CNN with PyTorch.</p>
  </li>
  <li>
    <p>Faster R-CNN recorded 75.9 % of mAP when trained on COCO + PASCAL VOC 2007 + PASCAL VOC 2012, outperforming previous selective search based model.</p>
  </li>
</ul>

<p>‚ÄÉ‚ÄÉ <img src="https://github.com/SuminizZ/Algorithm/assets/92680829/7fa0024c-c4fb-4cd2-bc82-9e965bd7a4a8" width="750" /></p>

<p><br /></p>

<ul>
  <li>Next post will cover <strong>YOLO v1</strong> that uses single-stage object detection, integrating RPN and classifier into a single CNN networks to process the entire image at once.</li>
</ul>
:ET