I"I<h2 id="문제"><strong>문제</strong></h2>
<p>백준 트리의 부모 찾기 : 실버 2 
<img src="https://user-images.githubusercontent.com/92680829/140861441-ad1e7fae-d38a-4a34-90e3-bda84b9271ca.png" /></p>

<h2 id="solution"><strong>Solution</strong></h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="p">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">10000000</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span>

<span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>            
<span class="n">tree</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>        <span class="c1"># 트리 연결 구조에 대한 정보
</span><span class="n">parents</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>      <span class="c1"># 자기자신의 부모 노드를 입력하는 사전
</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">left</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">c</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">findP</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="n">root</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>       <span class="c1"># 한 번도 상위의 노드와 연결된 적이 없으면(즉, 부모노드가 없으면)
</span>            <span class="n">parents</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>
            <span class="n">findP</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="n">findP</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

</code></pre></div></div>

<h2 id="풀이과정-및-느낀점"><strong>풀이과정 및 느낀점</strong></h2>
<p>이 문제에서 가장 어려웠던 부분은 트리의 연결 구조이다.
<br />
부모노드 자식노드가 있으면 보통 부모 –&gt; 자식으로 일방향 연결을 하게 되는데, 
<br />
이번 문제는 input 으로 주어지는 두 노드 간의 부모, 자식 여부를 따로 알려주지 않았기 때문에 일단 양방향으로 연결하고,
<br />
이후에 최상위의 루트노드부터 dfs 를 돌리면서 현재 노드보다 상위의 노드는 다시 parent 설정을 하지 않도록 해줬다. 
<br />
주의할 점은, 재귀 limit 을 늘려줘야 문제를 통과할 수 있다는 것.</p>
:ET